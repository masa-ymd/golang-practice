# 2.1 名前

* 予約語…ifやswitchなど、名前として使えない
* 事前宣言…trueやintなど自分で宣言（上書き）可能

# 2.3 変数

初期値はゼロ値

* 数値は0
* ブーリアンはfalse
* 文字列は""
* インターフェースと参照型（スライス、ポインタ、マップ、チャネル、関数）はnil

## 2.3.1 省略変数宣言

var宣言はvar boiling float64 = 100のように初期化の値と本来の型が異なる場合、
後で値が代入されるので初期値が重要でない場合に使われる

省略変数宣言は左式のいずれかが、新しい変数であれば使える

## 2.3.2 ポインタ

* p := &x … pはポインタ
* *p … xの値を指す
* ポインタ変数を宣言する時、int *p
* ポインタは同じ変数をさしているかどちらもnilであれば等しい
* 関数内でポインタを生成し、そのポインタを返すと、呼び出し元でも消えずに使える
* 関数の引数 例えば(p *int)のpはエイリアスで呼び出し元の変数名を使わずに変数へのアクセスを可能にできる

## 2.3.3 new関数

new(T)はT型の無名変数を作成し、それをT型に対応するゼロ値に初期化、*T型のアドレスを返す
T型のdummy変数を作って、そのアドレスを取得するのと同じ結果になる
newを使うケースはまれ

## 2.3.4 変数の生存期間

* ヒープ…使用するサイズ、タイミングをアプリが管理できるメモリ領域
  サイズが大きいもの、可変なものを扱うのに適している
* スタック…OSやコンパイラが領域をメモリ領域を割り当てるものでサイズ変更できない
  サイズが小さいもの、特定の関数内でのみ使う場合に適している
* パッケージレベルの変数の生存期間はプログラムの実行全体となり固定
* ローカル変数の生存期間は動的で、到達不可能になるまで（ポインタ、その他参照から到達できなくなるまで）
  生存し続ける

# 2.4 代入

## 2.4.1 タプル代入

* x, y = y, x のように複数の値に一度に代入できる
* 代入で変数が更新される前に右辺の式が全て評価される

## 2.4.2 代入可能性

代入可能性…型が一致する必要がある。nilはインターフェース型や参照型の全ての変数に代入可能

# 2.5 型宣言

* type宣言は既存の型と同じ基底型をもつ、新たな名前付き型を定義できる
* 名前付き型は、基底型と区別をし、混在させないようにする手段を提供する
* 型宣言はパッケージレベルで書かれる場合がほとんど
* 同じ基底型を持っていても名前付き型が異なれば、比較、算術式での組み合わせは不可

# 2.7 スコープ

* スコープはコンパイル時の範囲で生存期間は実行時の範囲、意味が異なる
* レキシカルブロック…{}で囲まれたもの、またはforの初期化宣言など、明示的に囲まれていないもので、宣言した変数が参照できる範囲
* ユニバースブロック…ソースコード全体を意味する
* パッケージレベルの宣言…関数の外で宣言され、同じパッケージのどこからでも参照可能
* ファイルレベルの宣言…インポートなど同じファイル内で参照可能
* ユニバースブロックで宣言された名前はレキシカルスコープ内で宣言（上書き）できる
* コンパイラは名前への参照を見つけると一番内側のレキシカルブロックから順に、外側に向けて宣言を探していく->内側の宣言が見つかると外側の同名の宣言は使えない-> 隠蔽している
